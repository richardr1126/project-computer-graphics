#include "arrow.h"
#include "../utils.h"
#include <math.h>

/*
 *  Draw a cylinder
 *  r: radius
 *  h: height
 */
static void Cylinder(double r, double h)
{
    const int d = 15;
    glBegin(GL_QUAD_STRIP);
    for (int th = 0; th <= 360; th += d)
    {
        double x = r * Cos(th);
        double y = r * Sin(th);
        glNormal3d(Cos(th), Sin(th), 0);
        glVertex3d(x, y, 0);
        glVertex3d(x, y, h);
    }
    glEnd();
    
    // Caps are not strictly needed for the arrow shaft as they are covered,
    // but for completeness or if the arrow breaks, we might want them.
    // For now, skipping caps for the shaft to match previous behavior roughly.
}

/*
 *  Draw a cone
 *  r: radius
 *  h: height
 */
static void Cone(double r, double h)
{
    const int d = 15;
    glBegin(GL_TRIANGLE_FAN);
    glNormal3d(0, 0, 1); // Tip normal approximation
    glVertex3d(0, 0, h);
    for (int th = 0; th <= 360; th += d)
    {
        double x = r * Cos(th);
        double y = r * Sin(th);
        // Normal vector for the side
        // Slope is r/h. Normal vector (h, 0, r) rotated.
        // Or just use the simple approximation for now.
        // Correct normal:
        double len = sqrt(r*r + h*h);
        double nx = h/len * Cos(th);
        double ny = h/len * Sin(th);
        double nz = r/len;
        
        glNormal3d(nx, ny, nz);
        glVertex3d(x, y, 0);
    }
    glEnd();
    
    // Base cap
    glBegin(GL_TRIANGLE_FAN);
    glNormal3d(0, 0, -1);
    glVertex3d(0, 0, 0);
    for (int th = 360; th >= 0; th -= d)
    {
        double x = r * Cos(th);
        double y = r * Sin(th);
        glVertex3d(x, y, 0);
    }
    glEnd();
}

/*
 *  Draw normals for the arrow (generated by AI)
 */
static void drawArrowNormals(double shaftRadius, double shaftLength, double tipRadius, double tipLength, double fletchLength, double fletchWidth)
{
    glColor3f(1.0, 1.0, 0.0); // Yellow
    glBegin(GL_LINES);
    
    const double len = 0.1; // Normal line length
    
    // Shaft normals
    for (int i = 0; i < 8; i++) {
        double th = i * 45.0;
        double x = shaftRadius * Cos(th);
        double y = shaftRadius * Sin(th);
        double nx = Cos(th);
        double ny = Sin(th);
        
        // Base
        glVertex3d(x, y, 0);
        glVertex3d(x + nx*len, y + ny*len, 0);
        
        // Middle
        glVertex3d(x, y, shaftLength/2);
        glVertex3d(x + nx*len, y + ny*len, shaftLength/2);
        
        // Top
        glVertex3d(x, y, shaftLength);
        glVertex3d(x + nx*len, y + ny*len, shaftLength);
    }
    
    // Tip normals
    for (int i = 0; i < 8; i++) {
        double th = i * 45.0;
        double x = tipRadius * Cos(th);
        double y = tipRadius * Sin(th);
        
        // Cone side normal approximation (perpendicular to surface)
        // Slope is r/h. Normal vector (h, 0, r) rotated.
        double r = tipRadius;
        double h = tipLength;
        double l = sqrt(r*r + h*h);
        double nx = (h/l) * Cos(th);
        double ny = (h/l) * Sin(th);
        double nz = r/l;
        
        // Draw at base of cone (relative to cone start)
        glVertex3d(x, y, shaftLength);
        glVertex3d(x + nx*len, y + ny*len, shaftLength + nz*len);
        
        // Draw halfway up cone
        glVertex3d(x/2, y/2, shaftLength + h/2);
        glVertex3d(x/2 + nx*len, y/2 + ny*len, shaftLength + h/2 + nz*len);
    }

    // Fletching normals
    for (int i = 0; i < 3; i++) {
        double th = 120.0 * i;
        double cy = shaftRadius + fletchWidth / 2.0;
        double cz = fletchLength / 2.0;
        
        // Position (rotated from 0, cy, cz around Z)
        double px = -cy * Sin(th);
        double py = cy * Cos(th);
        double pz = cz;
        
        // Normal 1 (1, 0, 0) rotated
        double nx1 = Cos(th);
        double ny1 = Sin(th);
        
        glVertex3d(px, py, pz);
        glVertex3d(px + nx1*len, py + ny1*len, pz);
        
        // Normal 2 (-1, 0, 0) rotated
        double nx2 = -Cos(th);
        double ny2 = -Sin(th);
        
        glVertex3d(px, py, pz);
        glVertex3d(px + nx2*len, py + ny2*len, pz);
    }
    
    glEnd();
}

/*
 *  Draw an arrow from an Arrow struct
 */
void drawArrow(const Arrow* arrow, int showNormals)
{
    if (!arrow) return;

    double x = arrow->x;
    double y = arrow->y;
    double z = arrow->z;
    double dx = arrow->dx;
    double dy = arrow->dy;
    double dz = arrow->dz;

    // Calculate rotation angles to align the arrow with (dx,dy,dz)
    // Default arrow points along +Z axis
    double length = Sqrt(dx*dx + dy*dy + dz*dz);
    if (length < 1e-6) return;

    // Normalize direction
    // We want to rotate from (0,0,1) to (dx,dy,dz)
    
    // Calculate yaw (rotation around Y) and pitch (rotation around X)
    // Standard conversion from Cartesian to Spherical coordinates
    // But we need to be careful with the initial orientation.
    // Let's assume the arrow is initially pointing along +Z.
    
    double yaw = atan2(dx, dz) * 180.0 / M_PI;
    double pitch = -asin(dy / length) * 180.0 / M_PI;

    glPushMatrix();
    
    // Translate to position
    glTranslated(x, y, z);
    
    // Rotate to direction
    glRotated(yaw, 0, 1, 0);
    glRotated(pitch, 1, 0, 0);
    
    // Scale if needed
    if (arrow->scale > 0.0) {
        glScaled(arrow->scale, arrow->scale, arrow->scale);
    }
    
    // Draw Shaft (Cylinder)
    // Cylinder starts at Z=0 and goes to Z=length
    glColor3f(0.6, 0.4, 0.2); // Wood color
    double shaftLength = 3.0;
    double shaftRadius = 0.05;
    Cylinder(shaftRadius, shaftLength);
    
    // Draw Tip (Cone)
    glPushMatrix();
    glTranslated(0, 0, shaftLength);
    glColor3f(0.5, 0.5, 0.5); // Metal color
    double tipLength = 0.5;
    double tipRadius = 0.1;
    Cone(tipRadius, tipLength);
    glPopMatrix();
    
    // Draw Fletching (Feathers)
    // 3 feathers at 120 degrees
    glColor3f(1.0, 0.0, 0.0); // Red feathers
    double fletchLength = 0.8;
    double fletchWidth = 0.2;
    
    for (int i = 0; i < 3; i++) {
        glPushMatrix();
        glRotated(120 * i, 0, 0, 1);
        glBegin(GL_TRIANGLES);
        // Simple triangle fletching
        glNormal3d(1, 0, 0); // Approximate normal
        glVertex3d(0, shaftRadius, 0);
        glVertex3d(0, shaftRadius + fletchWidth, 0.2);
        glVertex3d(0, shaftRadius, fletchLength);
        
        // Double sided?
        glNormal3d(-1, 0, 0);
        glVertex3d(0, shaftRadius, fletchLength);
        glVertex3d(0, shaftRadius + fletchWidth, 0.2);
        glVertex3d(0, shaftRadius, 0);
        glEnd();
        glPopMatrix();
    }
    
    // Draw Normals if requested
    if (showNormals) {
        // Disable lighting for lines
        glDisable(GL_LIGHTING);
        drawArrowNormals(shaftRadius, shaftLength, tipRadius, tipLength, fletchLength, fletchWidth);
        glEnable(GL_LIGHTING);
    }
    
    glPopMatrix();
}
