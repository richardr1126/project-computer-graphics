#include "arrow.h"
#include "../utils.h"

/*
 *  Draw a cylinder
 *  @param r radius
 *  @param h height
 */
static void Cylinder(double r, double h) {
  const int d = 15;
  glBegin(GL_QUAD_STRIP);
  for (int th = 0; th <= 360; th += d) {
    double x = r * Cos(th);
    double y = r * Sin(th);
    glNormal3d(Cos(th), Sin(th), 0);
    glVertex3d(x, y, 0);
    glVertex3d(x, y, h);
  }
  glEnd();

  // Bottom cap
  glBegin(GL_TRIANGLE_FAN);
  glNormal3d(0, 0, -1);
  glVertex3d(0, 0, 0);
  for (int th = 360; th >= 0; th -= d) {
    double x = r * Cos(th);
    double y = r * Sin(th);
    glVertex3d(x, y, 0);
  }
  glEnd();
}

/*
 *  Draw a cone
 *  @param r radius
 *  @param h height
 */
static void Cone(double r, double h) {
  const int d = 15;
  glBegin(GL_TRIANGLE_FAN);
  glNormal3d(0, 0, 1); // Tip normal approximation
  glVertex3d(0, 0, h);
  for (int th = 0; th <= 360; th += d) {
    double x = r * Cos(th);
    double y = r * Sin(th);
    // Side normals
    double len = sqrt(r * r + h * h);
    double nx = h / len * Cos(th);
    double ny = h / len * Sin(th);
    double nz = r / len;

    glNormal3d(nx, ny, nz);
    glVertex3d(x, y, 0);
  }
  glEnd();

  // Base cap
  glBegin(GL_TRIANGLE_FAN);
  glNormal3d(0, 0, -1);
  glVertex3d(0, 0, 0);
  for (int th = 360; th >= 0; th -= d) {
    double x = r * Cos(th);
    double y = r * Sin(th);
    glVertex3d(x, y, 0);
  }
  glEnd();
}

/*
 *  Draw normals for the arrow
 *  (generated by AI)
 *  @param shaftRadius radius of the arrow shaft
 *  @param shaftLength length of the arrow shaft
 *  @param tipRadius radius of the arrow tip
 *  @param tipLength length of the arrow tip
 *  @param fletchLength length of the arrow fletching
 *  @param fletchWidth width of the arrow fletching
 */
static void drawArrowNormals(double shaftRadius, double shaftLength,
                             double tipRadius, double tipLength,
                             double fletchLength, double fletchWidth) {
  glColor3f(1.0, 1.0, 0.0); // Yellow
  glBegin(GL_LINES);

  const double len = 0.1; // Normal line length

  // Shaft normals
  for (int i = 0; i < 8; i++) {
    double th = i * 45.0;
    double x = shaftRadius * Cos(th);
    double y = shaftRadius * Sin(th);
    double nx = Cos(th);
    double ny = Sin(th);

    // Base
    glVertex3d(x, y, 0);
    glVertex3d(x + nx * len, y + ny * len, 0);

    // Middle
    glVertex3d(x, y, shaftLength / 2);
    glVertex3d(x + nx * len, y + ny * len, shaftLength / 2);

    // Top
    glVertex3d(x, y, shaftLength);
    glVertex3d(x + nx * len, y + ny * len, shaftLength);
  }

  // Tip normals
  for (int i = 0; i < 8; i++) {
    double th = i * 45.0;
    double x = tipRadius * Cos(th);
    double y = tipRadius * Sin(th);

    // Cone side normal approximation (perpendicular to surface)
    // Slope is r/h. Normal vector (h, 0, r) rotated.
    double r = tipRadius;
    double h = tipLength;
    double l = sqrt(r * r + h * h);
    double nx = (h / l) * Cos(th);
    double ny = (h / l) * Sin(th);
    double nz = r / l;

    // Draw at base of cone (relative to cone start)
    glVertex3d(x, y, shaftLength);
    glVertex3d(x + nx * len, y + ny * len, shaftLength + nz * len);

    // Draw halfway up cone
    glVertex3d(x / 2, y / 2, shaftLength + h / 2);
    glVertex3d(x / 2 + nx * len, y / 2 + ny * len,
               shaftLength + h / 2 + nz * len);
  }

  // Fletching normals
  for (int i = 0; i < 3; i++) {
    double th = 120.0 * i;
    double cy = shaftRadius + fletchWidth / 2.0;
    double cz = fletchLength / 2.0;

    // Position (rotated from 0, cy, cz around Z)
    double px = -cy * Sin(th);
    double py = cy * Cos(th);
    double pz = cz;

    // Normal 1 (1, 0, 0) rotated
    double nx1 = Cos(th);
    double ny1 = Sin(th);

    glVertex3d(px, py, pz);
    glVertex3d(px + nx1 * len, py + ny1 * len, pz);

    // Normal 2 (-1, 0, 0) rotated
    double nx2 = -Cos(th);
    double ny2 = -Sin(th);

    glVertex3d(px, py, pz);
    glVertex3d(px + nx2 * len, py + ny2 * len, pz);
  }

  glEnd();
}

/*
 *  Draw an arrow from an Arrow struct
 *  @param arrow pointer to Arrow structure
 *  @param showNormals 1 to draw normals, 0 otherwise
 */
void drawArrow(const Arrow *arrow, int showNormals) {
  if (!arrow || !arrow->active) return;

  double x = arrow->x;
  double y = arrow->y;
  double z = arrow->z;
  double dx = arrow->dx;
  double dy = arrow->dy;
  double dz = arrow->dz;

  // Calculate rotation angles to align the arrow with (dx,dy,dz)
  // Default arrow points along +Z axis
  double length = sqrt(dx * dx + dy * dy + dz * dz);
  if (length < 1e-6) return;

  // Normalize direction
  // Calculate yaw (rotation around Y) and pitch (rotation around X)
  // Arrow is initially pointing along +Z.
  double yaw = atan2(dx, dz) * 180.0 / M_PI;
  double pitch = -asin(dy / length) * 180.0 / M_PI;

  glPushMatrix();

  // Translate to position
  glTranslated(x, y, z);

  // Rotate to direction
  glRotated(yaw, 0, 1, 0);
  glRotated(pitch, 1, 0, 0);

  // Scale if needed
  if (arrow->scale > 0.0) glScaled(arrow->scale, arrow->scale, arrow->scale);

  // Draw Shaft (Cylinder)
  // Cylinder starts at Z=0 and goes to Z=length
  glColor3f(0.6, 0.4, 0.2); // Wood color
  double shaftLength = 3.0;
  double shaftRadius = 0.05;
  Cylinder(shaftRadius, shaftLength);

  // Draw Tip (Cone)
  glPushMatrix();
  glTranslated(0, 0, shaftLength);
  glColor3f(0.5, 0.5, 0.5); // Metal color
  double tipLength = 0.5;
  double tipRadius = 0.1;
  Cone(tipRadius, tipLength);
  glPopMatrix();

  // Draw Fletching (Feathers)
  // 3 feathers at 120 degrees
  glColor3f(1.0, 0.0, 0.0); // Red feathers
  double fletchLength = 0.8;
  double fletchWidth = 0.2;

  for (int i = 0; i < 3; i++) {
    glPushMatrix();
    glRotated(120 * i, 0, 0, 1);
    glBegin(GL_TRIANGLES);
    // Simple triangle fletching
    glNormal3d(1, 0, 0); // Approximate normal
    glVertex3d(0, shaftRadius, 0);
    glVertex3d(0, shaftRadius + fletchWidth, 0.2);
    glVertex3d(0, shaftRadius, fletchLength);

    // Double sided?
    glNormal3d(-1, 0, 0);
    glVertex3d(0, shaftRadius, fletchLength);
    glVertex3d(0, shaftRadius + fletchWidth, 0.2);
    glVertex3d(0, shaftRadius, 0);
    glEnd();
    glPopMatrix();
  }

  // Draw Normals if requested
  if (showNormals) {
    // Disable lighting for lines
    glDisable(GL_LIGHTING);
    drawArrowNormals(shaftRadius, shaftLength, tipRadius, tipLength,
                     fletchLength, fletchWidth);
    glEnable(GL_LIGHTING);
  }

  glPopMatrix();
}

/*
 *  Update arrow physics
 *  @param arrow pointer to Arrow structure
 *  @param dt time delta in seconds
 */
void updateArrow(Arrow *arrow, double dt) {
  if (!arrow || !arrow->active) return;

  // Gravity
  const double g = 9.8; // m/s^2
  arrow->vy -= g * dt;

  // Update position
  arrow->x += arrow->vx * dt;
  arrow->y += arrow->vy * dt;
  arrow->z += arrow->vz * dt;

  // Update direction to match velocity
  double speed = sqrt(arrow->vx * arrow->vx + arrow->vy * arrow->vy +
                      arrow->vz * arrow->vz);
  if (speed > 0.001) {
    arrow->dx = arrow->vx / speed;
    arrow->dy = arrow->vy / speed;
    arrow->dz = arrow->vz / speed;
  }

  // Collision 
  // TODO
}

/*
 *  Shoot arrow from position with angle
 *  @param arrow pointer to Arrow structure
 *  @param x starting position x
 *  @param y starting position y
 *  @param z starting position z
 *  @param th view angle theta (degrees)
 *  @param ph view angle phi (degrees)
 *  @param speed initial speed
 */
void shootArrow(Arrow *arrow, double x, double y, double z, double th,
                double ph, double speed) {
  if (!arrow) return;

  arrow->active = 1;
  arrow->x = x;
  arrow->y = y;
  arrow->z = z;
  arrow->scale = 1.0;

  // Convert view angles to direction vector
  DirectionFromAngles(th, ph, &arrow->dx, &arrow->dy, &arrow->dz);

  // Set velocity
  arrow->vx = arrow->dx * speed;
  arrow->vy = arrow->dy * speed;
  arrow->vz = arrow->dz * speed;
}
